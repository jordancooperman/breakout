<!doctype html>
<html>
<head>
  <title></title>
</head>
<body>
  <!-- <script type="text/javascript" src="js/vector2.js"></script> -->
  <link href="assets/css/include.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="assets/js/canvas.js"></script>
  <script type="text/javascript" src="assets/js/particle.js"></script>
  <script type="text/javascript" src="assets/js/rect.js"></script>
</head>
<body>
  <script type="text/javascript">

    // global variables
    var ctx,
 	      screenWidth = window.innerWidth,
        screenHeight = window.innerHeight,
        halfWidth = screenWidth / 2,
        halfHeight = screenHeight / 2;

    // mouse position
    var mouseX = halfWidth,
        mouseY = 0;

    // create the necessary objects
    var brickCanvas = new Canvas(screenWidth, screenHeight),
				canvas = new Canvas(screenWidth, screenHeight),
        paddle = new Rect(),
        particle = new Particle(4),
				bricks = [],
				lastInCol = [];

    // configure objects
    paddle.width = 50;
    paddle.height = 10;
		paddle.posX = halfWidth - paddle.width/2;
		paddle.posY = screenHeight - 25;

		particle.posX = halfWidth;
		particle.posY = paddle.posY - particle.size*2;
		particle.velX = 0;
    particle.velY = -4;

    // setup event listeners

		canvas.make();
		brickCanvas.make();

		var colHeight = 8;

    brickCanvas.canvasElement.addEventListener('mousemove', onMouseMove, false);
    brickCanvas.canvasElement.addEventListener('mouseup', onMouseUp, false);

    var click = false;

    // variables to see if the game is over

    var game_over = false,
        new_game = false;

    // get this party started
    init();

    function init() {
      paddle.render(canvas.ctx);
			makeBrickField(100);
			for (var i = 0; i < bricks.length; i++) {
				var brick = bricks[i];

				brick.render(brickCanvas.ctx);
			}

      setInterval(function() {
        loop();
      }, 1000/60);
    }

    function loop() {
			if (game_over == false) {
				paddle.target = mouseX - (paddle.width/2);

				canvas.clear();

	      paddle.render(canvas.ctx);
	      particle.render(canvas.ctx);

				if (click == true) {
					paddle.update();
					particle.update();
					collisionDetection();
				}
			}
			else {
				return;
			}
    }

		function makeBrickField(brickCount) {
	    this.row = 0;
	    this.inRow = 0;
	    this.col = 0;
	    this.width = 50;
	    this.brickDivision = 10;
	    this.maxInRow = Math.round(screenWidth/(this.width + this.brickDivision));
	    this.brickCount = this.maxInRow * this.colHeight;


			var i = 0,
			    y = 0,
			    colHeight = colHeight,
					length =  this.brickCount;

			for (i; i < length; i++) {
			  brick = new Rect(),
				brick.width = this.width;
				brick.height = 10;
				brick.lastInCol = false;

				brick.posX = this.col * brick.width + (this.col * this.brickDivision);

				brick.posY = 10 * y + (y * this.brickDivision);
        y++;
        // this.inRow++;

        if (y >= this.colHeight) {
          y = 0;
          this.col++
        }
        // if (this.inRow >= this.maxInRow) {
        //   this.inRow = 0;
        //   this.row++;
        // }

				bricks.push(brick);
			}
		};

    function collisionDetection() {

			var i = 0,
			    length = bricks.length;

			for (i; i < length; i++) {
  			if ( (particle.posY <= (bricks[i].posY + brick.height)) ) {
          if ( (particle.posX >= bricks[i].posX) && (particle.posX <= bricks[i].posX + brick.width) ) {
            bricks[i].erase(brickCanvas.ctx);
            bricks.remove(i);

            length = lastInCol.length;
    				particle.reverseY();
          }
  			}
			};

			// detect if the particle hits the walls
			// ...and reverse its dipaddleion
	    if (particle.posY <= 0) {
				particle.reverseY();
	    }
	    else if ((particle.posX >= screenWidth) || (particle.posX <= 0)) {
				particle.reverseX();
	    }

			// detect if the particle hits the paddle
			// ...and reverse its dipaddleion
	    else if (particle.posY >= paddle.posY && particle.posY <= paddle.posY + paddle.height) {

				if ((particle.posX >= (mouseX - paddle.width/2)) && (particle.posX <= (mouseX + paddle.width/2))) {
					particle.reverseY();
					particle.velX *= 1.02;
	        particle.velY *= 1.02;

					if (particle.posX <= mouseX) {
						particle.velX += -1-random(0,0.6);
					}
	        else {
						particle.velX += 1+random(0,0.6);
	        }
			  }
	     else if (particle.posY > screenHeight + particle.size*2) {
	         game_over = true;
	         end_text = document.createElement( 'div' );
	         end_text.id = "end_text";
	         end_text.style.marginTop = halfHeight + "px";
	         document.body.appendChild(end_text);
	         document.getElementById('end_text').innerHTML = "<p>Game Over</p><a href=\"#\" class=\"restart\">Play Again</a>";
	         // end_text.addEventListener('click', restart, false);
	     }
	    }
    };

    // function restart() {
    //     game_over = false;
    //     new_game = true;
    //     init();
    // }

		// event handler functions
    function onMouseMove(event) {
    	mouseX = event.clientX;
    	mouseY = event.clientY;
    };

    function onMouseUp() {
      click = true;
    };

		// assorted functions
    function random(min, max) {
        return (Math.random()*(max-min) + min)
    };

    // Array Remove - By John Resig (MIT Licensed)
    Array.prototype.remove = function(from, to) {
      var rest = this.slice((to || from) + 1 || this.length);
      this.length = from < 0 ? this.length + from : from;
      return this.push.apply(this, rest);
    };

    </script>
</body>
</html>
